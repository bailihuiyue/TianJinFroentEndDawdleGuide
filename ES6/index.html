<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ES6常见概念</title>
    <link href="../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../static/highlight/styles/default.css">
    <script src="../static/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
        .bold {
            font-weight: bold;
            width: 50px;
        }

        img {
            max-width: 100%;
            display: block;
            margin: 5px 0;
        }

        .todo {
            color: #e30000
        }

        .title {
            font-size: 19px;
            color: #e30000;
        }

        table {
            width: 80%;
        }

        pre {
            border: none;
            border-radius: 0;
        }
    </style>
</head>

<body>
    <h2 class="text-center">ES6常见概念总结</h2>
    <div class="container">
        <table class="table table-bordered table-hover">
            <tr>
                <td>Let与const</td>
                <td>
                    <img src="./images/ES615.png">
                    <div>//报错:未定义</div>
                    <img src="./images/ES628.png">
                    <div>// zneg liang</div>
                    <img src="./images/ES645.png">
                </td>
                <td>
                    <div>如果函数内部有相同的变量定义,不论定义位置,都是屏蔽掉外部的定义</div>
                    <div>如果是var声明,由于存在变量提升,结果就是undefined,如果是let,没有提升,则会报错</div>
                    <br><br><br><br>
                    <div>Const并不是声明的值不可以修改,而是声明的常亮指针不可修改</div>
                    <br><br><br><br><br><br>
                    <div>完全冻结一个变量,使其无法被更改</div>
                </td>
                <td>
                    <div>Es5函数声明会被提升,es6不会,使用 ‘use strict’可以开启es6模式</div>
                    <div class="todo">注:let有一个暂时性死区的概念</div>
                </td>
            </tr>
            <tr>
                <td>hasOwnProperty</td>
                <td>
                    <pre><code class="javascript">//用法：`obj.hasOwnProperty(key)
//obj为对象 key为所要判断的字符串`
//判断一个对象属性里是否包含某个key，key为字符串,此方法不会去判断原型
var obj={
    key:123
};
obj.hasOwnProperty('key');//true
obj.hasOwnProperty('hasOwnProperty');//false</code></pre>
                </td>
                <td>
                    <div>参考文档:
                        <a href="https://www.cnblogs.com/weiqinl/p/8683207.html">js属性对象的hasOwnProperty方法</a>
                    </div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>Class</td>
                <td>
                    <pre><code class="javascript">class Person{//定义了一个名字为Person的类
constructor(name,age){
    //constructor是一个构造方法，用来接收参数
        this.name = name;//this代表的是实例对象
        this.age=age;
    }
    say(){//这是一个类的方法，注意千万不要加上function
        return "我的名字叫" + this.name+"今年"+this.age+"岁了";
    }
}
var obj=new Person("laotie",88);
console.log(obj.say());
//我的名字叫laotie今年88岁了</code></pre>
                </td>
                <td>
                    <div style="width: 300px">
                        constructor中定义的属性可以称为实例属性（即定义在this对象上），constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)。hasOwnProperty()函数用于判断属性是否是实例属性。其结果是一个布尔值，
                        true说明是实例属性，false说明不是实例属性。in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例中还是原型中.</div>
                </td>
                <td>
                    <div><span class="todo"
                            style="width: 300px">class不存在变量提升</span>，所以需要先定义再使用。因为ES6不会把类的声明提升到代码头部，但是ES5就不一样,<span
                            class="todo">ES5存在变量提升</span>,可以先使用，然后再定义。</div>
                </td>
            </tr>
            <tr>
                <td></td>
                <td>Super</td>
                <td>
                    <div>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</div>
                    <pre><code class="javascript">class A {}
class B extends A { 
    constructor() {
      super();
    }
}</code></pre>
                    <div>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</div>
                    <div><span
                            class="todo">注意，</span>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。
                    </div>
                </td>
                <td><a href="https://blog.csdn.net/linusc/article/details/78770755">ES6 Class继承中super在不同场景中的用法</a></td>
            </tr>
            <tr>
                <td></td>
                <td>Static</td>
                <td><img src="./images/ES61602.png"></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td>exntend</td>
                <td><img src="./images/ES61615.png"></td>
                <td></td>
            </tr>
            <tr>
                <td>For of</td>
                <td>可以跳出循环(break,continue),之前的for in 不可以</td>
                <td>for(let k in arr) k是key,<br>但of里面是值</td>
                <td></td>
            </tr>
            <tr>
                <td>Symbol</td>
                <td>
                    <div>
                        ES5对象属性名都是字符串容易造成属性名的冲突。<br>
                        ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。<br>
                        基本数据类型新增Symbol
                    </div>
                </td>
                <td>
                    <pre><code class="javascript">// 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();
s1 === s2 // false
// 有参数的情况
var s1 = Symbol("foo");
var s2 = Symbol("foo");
s1 === s2 // false</code></pre>
                </td>
                <td>
                    <a href="https://www.cnblogs.com/sker/p/5474591.html">ES6入门之Symbol</a>
                    <a href="https://www.jianshu.com/p/f40a77bbd74e">理解和使用ES6中的Symbol</a>
                </td>
            </tr>
            <tr>
                <td>Iterator遍历器</td>
                <td>具有Iterator接口的对象可以被for of 消费(调用)</td>
                <td>Es6中,数组set,map包括字符串,都实现了Iterator接口</td>
                <td><a href="https://www.jianshu.com/p/3bb77516fa7e">ES6 迭代器(Iterator)和 for...of循环使用方法</a></td>
            </tr>
            <tr>
                <td>generator</td>
                <td>
                    <img src="./images/ES62280.png">
                    <div>
                        每次调用next()时yield自动会返回yield的值,但是用var a = yield 1的方式接不到值,也就是a是undefined
                        Yield如果不在next中传值,返回的值默认就是undefined
                        next中传值是唯一可以让yield有返回值的方法,
                    </div>
                    <pre><code class="javascript">function sum(a, b) {
                            console.log(a,b)
                            return a + b
                        }
                        function* a() {
                            console.log(1)
                            var x=yield 1
                            console.log(2)
                            var z=yield 2
                            console.log(3)
                            var b = sum(x,z)
                            console.log(4) 
                            return b
                        }</code></pre>
                    <img src="./images/ES62601.png">
                    <img src="./images/ES62603.png">
                    <img src="./images/ES62605.png">
                </td>
                <td>
                    <div>For of 不会打印出done为true的内容,也是4不会被打印出来</div>
                    <img src="./images/ES62643.png">
                    <div>第一次调用.next时函数会跳到第一个yield语句上,但是还没有执行,第二次调用next时才会执行第一个yield,因此第一次调用next(5)并不会为第一个yield赋值</div>
                    <div>捕获异常</div>
                    <img src="./images/ES62740.png">
                </td>
                <td><a href="https://www.jianshu.com/p/112373662dff">阮一峰es6要点总结——Generator</a></td>
            </tr>
            <tr>
                <td>set</td>
                <td>
                    生成一个不重复的数组
                    <img src="./images/ES62797.png">
                </td>
                <td>
                    语法:
                    <img src="./images/ES62803.png">
                </td>
                <td>
                    数组去重:
                    <img src="./images/ES62812.png">
                </td>
            </tr>
            <tr>
                <td>map</td>
                <td>
                    <div>Key可以是任意值,相同的key会被覆盖</div>
                    <img src="./images/ES62840.png">
                </td>
                <td></td>
                <td>Map可以传键值对,set只能传数,是一个类数组</td>
            </tr>
            <tr>
                <td>Array</td>
                <td>
                    <img src="./images/ES62877.png">
                </td>
                <td>
                    <div>From:可以将类数组转为数组同时第二个参数可以操作数组</div>
                    <img src="./images/ES62908.png">
                </td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td>
                    Of
                    <img src="./images/ES62917.png">
                </td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td>
                    <div>Find:查找匹配到结果的第一个值</div>
                    <img src="./images/ES62941.png">
                    <div>比indexOf更强大,可以查找到NaN,indexOf不行</div>
                    <img src="./images/ES62974.png">
                </td>
                <td></td>
            </tr>
            <tr>
                <td>ArrayBuff</td>
                <td>
                    <img src="./images/ES62988.png">
                    <div>类型化数组:<br>Unit8array 无符号8位,范围0-255<br>Int8Array 有符号8位,范围-128到127<br><br>作用,读取二进制文件,或者图片进行修改
                    </div>
                </td>
                <td>
                    <div>dataView 更方便的操作buff</div>
                    <img src="./images/ES63069.png">
                </td>
                <td>
                    <img src="./images/ES63071.png">
                    <div>Subarray和Int16Array用的是一个内存地址</div>
                </td>
            </tr>
            <tr>
                <td>object</td>
                <td><img src="./images/ES63136.png"></td>
                <td>
                    <pre><code class="javascript">Object.is(NaN,NaN) 结果为true
+0 === -0 //true
NaN === NaN // false
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true</code></pre>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>Object.assign</td>
                <td>
                    <img src="./images/ES63275.png">
                    <div>obj是完全等于obj2的</div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Object的遍历</td>
                <td>
                    <img src="./images/ES63304.png">
                </td>
                <td>
                    <div>
                        <a href="https://www.cnblogs.com/kongxy/p/4618173.html">JavaScript中的可枚举属性与不可枚举属性</a>
                        <img src="./images/ES63358.png" style="display: block">
                        <div>通过class创建的属性是不可枚举的,而通过prototype创建的则是可以枚举的</div>
                    </div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>
                    <div>设置原型对象:</div>


                </td>
                <td>
                    <pre><code class="javascript">Object.setPrototypeOf(obj,a);
Object.getPrototypeOf(obj);</code></pre>
                </td>
                <td>
                    <div>Es6 推荐的设置原型对象的方法</div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>string字符串类</td>
                <td>
                    <img src="./images/ES63537.png">
                    <div>${}内部可以嵌入三元表达式或者方法</div>
                </td>
                <td>
                    <img src="./images/ES63558.png">
                    <div>输出结果:</div>
                    <img src="./images/ES63566.png">
                    <div>tag`${name}`这种奇怪的语法可以把模板字符串转换成一个个的字符传到方法里,这样可以用来过滤字符,比如做一个安全的html,把<>转成<>
                                方法中的字符串分割是以${}这种东西为分界线的</div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>箭头函数</td>
                <td>
                    <div>1. 箭头函数中没有arguments</div>
                    <div>2. 单行不用写return,多行要返回值的话必须写</div>
                    <div>3. 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),</div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>数组解构</td>
                <td>
                    <img src="./images/ES63777.png">
                    <img src="./images/ES63777.png">
                    <img src="./images/ES63779.png">
                    <img src="./images/ES63781.png">
                    <img src="./images/ES63783.png">
                    <img src="./images/ES63785.png">
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>对象解构</td>
                <td>
                    <pre><code class="javascript">var {name:name2}={name:’aaa’}
console.log(name)
此时会报错,因为那么并没有值,而name2其实被赋值为’aaa’
同理,下图的log(a,b)也一样会报错,相当于a不存在,而是把{b:{c}}赋值解构了
而{namex}={name:’123’}
没有报错是因为该写法相当于
{namex:namex}={name:’123’},
所以log name是可以有结果的</code></pre>
                    <img src="./images/ES64001.png">
                    <img src="./images/ES64003.png">
                    <div>只有undefined才能被x=15这样覆盖,其他值都不可以,包括null,x也会是null</div>
                    <img src="./images/ES64052.png">
                    <img src="./images/ES64054.png">
                    <div>Name被重复定义,也会报错</div>
                    <img src="./images/ES64072.png">
                    <div>运行结果为 h e l</div>
                </td>
                <td>
                    <div>练习:</div>
                    <img src="./images/ES64090.png">
                    <div>直接运行test会报错,因为test([])相当于只有key,而没有value,左边没办法解析的</div>
                    <img src="./images/ES64142.png">
                    <div>结果为 2 3 90</div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
        </table>
    </div>
</body>

</html>