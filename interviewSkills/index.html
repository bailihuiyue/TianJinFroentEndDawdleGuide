<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>面试经验--前端跳槽面试常见问题</title>
</head>
<link rel="stylesheet" href="../static/highlight/styles/default.css">
<script src="../static/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<style>
  body {
    background-color: #EEEFF5
  }

  * {
    font-family: '-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol';
  }

  .bold {
    font-weight: bold;
    width: 50px;
  }

  table {
    border-collapse: collapse;
    width: 80%;
    margin: auto;
    background: #fff;
  }

  th,
  td {
    border: 1px solid #DFE2E5;
    border-collapse: collapse;
    padding: 5px;
    text-align: left;
  }

  tr:nth-child(odd) {
    background-color: #F8F8F8;
  }

  tr:hover {
    background-color: #e4ebf0;
  }

  ul,
  li {
    margin: 5px;
  }

  div {
    margin: 5px 0;
  }

  img {
    max-width: 100%;
  }

  .todo {
    color: #e30000
  }

  a {
    word-wrap: break-word;
    word-break: normal;
  }

  .title {
    font-size: 19px;
    color: #e30000;
  }

  .center {
    text-align: center;
  }
</style>

<body>
  <h2 class="center">前端跳槽面试常见问题</h2>
  <table>
    <tr>
      <td>Html5新增标签</td>
      <td><a href="https://www.cnblogs.com/nuanai/p/8856814.html">HTML5新增的标签及使用</a></td>
      <td>
        <pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;header&gt;
&lt;div&gt;
  &lt;section>定义一个区域&lt;/section&gt;
  &lt;aside>定义页面内容的侧边框部分&lt;/aside&gt;
&lt;/div&gt;
&lt;footer&gt;
&lt;nav&gt;
&lt;article&gt;
&lt;figure&gt;
&lt;dialog &gt;
&lt;menu&gt;
&lt;details&gt;
&lt;progress&gt;
&lt;audio&gt;
&lt;video&gt;
&lt;canvas&gt;</code></pre>
      </td>
      <td></td>
    </tr>
    <tr>
      <td><span class="title">面试准备-自我陈述方面</span></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>实例</div>
        <ul>
          <li>自如谈兴趣,巧妙示实例,适时讨疑问(1)</li>
          <li>节奏要适宜,切忌小聪明</li>
        </ul>
      </td>
      <td>1.遇到面试官提问不会的问题时,要说没有涉及过,想要弄明白这个问题,可否指点一下(主要表现出求知欲与谦虚)</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>实战</div>
        <ul>
          <li>
            <div>方向要对,过程要细</div>
          </li>
          <li>
            <div>胆子要大,心态要和</div>
          </li>
        </ul>
      </td>
      <td>遇到不会的不要灰心,要争取在面试中得到点什么,比如适时讨疑问,不要轻易放弃,学会之后是否还可以来面试</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><span class="title">一面/二面</span></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>jquery常见问题</div>
      </td>
      <td>
        <div>1.核心架构</div>
        <div>2.事件委托</div>
        <div>3.插件机制</div>
      </td>
      <td>
        <div>1.(慕课网:jq源码解析 架构 2-3)</div>
        <pre><code class="javascript">
ajQuery.fn = ajQuery.prototype = {
    name: 'aaron',
    init: function(selector) {
      this.selector = selector;
      return this;
    },
    constructor: ajQuery
}
ajQuery.fn.init.prototype = ajQuery.fn
            </code></pre>
        <div>2.(慕课网:jq源码解析 DOM 5-12)</div>
        <div>
          简单来说就是把
          target 到根节点 div 通过 node.parentNode 遍历一遍，然后找到对应的委托元素节点，如果符合就缓存起来用于之后的操作，可以通过 jQuery.event.handlers
          方法我们可以获取类似这种的一组数据结构
        </div>
        <pre><code class="javascript">$(document).on( "click" , "button",function(e){}</code></pre>
        <div>就是当点击document时查看子元素是否是button,是就执行方法</div>
        <div>参考网址:<a href="https://www.cnblogs.com/zhoushengxiu/p/5703095.html" target="_blank">链接</a></div>
        <div>3.(慕课网:jq源码解析 架构 2-5)</div>
        <pre><code class="javascript">
aAron.extend = aAron.fn.extend = function () {
  var options, src, copy,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length;
  //只有一个参数，就是对jQuery自身的扩展处理
  //extend,fn.extend
  if (i === length) {
      target = this; //调用的上下文对象jQuery/或者实例
      i--;
  }
  for (; i < length; i++) {
      //从i开始取参数,不为空开始遍历
      if ((options = arguments[i]) != null) {
          for (name in options) {
              copy = options[name];
              //覆盖拷贝
              target[name] = copy;
          }
      }
  }
  return target;
}
            </code></pre>
      </td>
      <td><img src="./img/20200824171218.png" alt=""></td>
    </tr>
    <tr>
      <td>
        <div>1.页面布局</div>
      </td>
      <td>
        <div>5种方法写出三栏布局:</div>
        <div>两边300px中间自适应</div>
      </td>
      <td>
        <div>1.float </div>
        <div>2.position</div>
        <div>3.flex</div>
        <div>4.table</div>
        <div>5.grid</div>
      </td>
      <td>
        <div>1.三个div的顺序应该是 left,right,center,原因是float属性可以让元素高度塌陷</div>
      </td>
    </tr>
    <tr>
      <td>
        <div>2.CSS盒模型</div>
      </td>
      <td>
        <div>1.标准模型:width=content</div>
        <div>2.IE模式(怪异模式):width=content+padding+border</div>
        <div>3.如何切换这两种模式:box-sizing:content-box(默认值,标准模式),可以切换为border-box(怪异模式)</div>
      </td>
      <td>
        <div>常见问题/提问方式</div>
        <div>1.基本概念:标准模型+ie模型</div>
        <div>2.两种模型之间的区别</div>
        <div>3.css如何设置这两种类型</div>
        <div>4.js如何获取盒模型对应的宽高</div>
        <div>5.根据盒模型解释边距重叠</div>
        <div>6.BFC(边距重叠解决方案 )</div>

        <div>注:如何解决边距重叠?</div>
        <div>答:两个div,给第二个div添加一个父元素并设置overflow即可</div>
      </td>
      <td>
        <div>解答:</div>
        <div>4.ele.style.width/height</div>
        <div>ele.currentStyle.width (IE)</div>
        <div>window.getComputedStyle(ele).width</div>
        <div>ele.getBoundingClientRect().width</div>
        <div>5.和BFC有关,具体案例查看视频3-4CSS盒模型(一) 时间14分</div>
        <div>BFC:块级格式化上下文</div>
        <div>6. 触发BFC的方式（一下任意一条就可以）</div>
        <div>1.float的值不为none</div>
        <div>2.overflow的值不为visible</div>
        <div>3.display的值为table-cell、tabble-caption和inline-block之一</div>
        <div>4.position的值不为static或则releative中的任何一个</div>
        <div>详情见网址:<a shape="rect" href="http://www.cnblogs.com/CafeMing/p/6252286.html"
            target="_blank">http://www.cnblogs.com/CafeMing/p/6252286.html</a><br clear="none" /></div>
        <div>或者笔记:&lt;&lt;BFC的布局规则以及触发条件</div>
      </td>
    </tr>
    <tr>
      <td>css样式修改</td>
      <td><img src="./img/20200827111027.png" alt=""></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>DOM事件类</div>
      </td>
      <td>
        <div>1.基本概念:DOM事件的级别</div>
        <div>2.DOM事件模型(冒泡,捕获)</div>
        <div>3.DOM事件流</div>
        <div>4.描述DOM事件捕获的具体流程</div>
        <div>5.Event对象的常见应用</div>
        <div>6.自定义事件</div>
      </td>
      <td>
        <div>DOM事件类:</div>
        <div>DOM0:ele.onclick 或者写在标签上</div>
        <div>DOM1: 1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型.</div>
        <pre><code class="javascript">DOM2:ele.addEventListener("click",function(){})
//DOM2支持多个事件绑定</code></pre>
        <pre><code class="javascript">DOM3:ele.addEventListener('keyup',function(){})
//还有自定义事件</code></pre>
        <div><span>事件模型:</span></div>
        <div>捕获,</div>
        <div>冒泡</div>
        <div><span>事件流:</span></div>
        <div>捕获</div>
        <div>目标阶段</div>
        <div>冒泡</div>
        <div><span>描述DOM事件捕获的具体流程</span></div>
        <div>window-&gt;document-&gt;html标签-&gt;body-&gt;.....-&gt;目标元素</div>
        <div>冒泡相反</div>
      </td>
      <td>
        <div> document.body可以获取body标签</div>
        <div>document.documentElement可以获取html标签</div>
        <div>document主要控制文档内容,如:document .title</div>
        <div>window主要控制浏览器,属于BOM的一个对象,如window.close();</div>
        <div><span>Event对象的常见应用</span></div>
        <div>e.preventDefault() 阻止默认事件</div>
        <div>e.stopPropagation() 阻止冒泡</div>
        <div>e.stopImmdeiatePropagation() 绑定多个事件的同一个元素,如果不加此方法,多个事件会全部触发,加上之后,没加的那些就不会触发了</div>
        <div><span>e.currentTarget 绑定事件的元素,也就是委托的父元素</span></div>
        <div><span>e.target 当前被点击的元素</span>(sourceElement早期ie)</div>
        <div>参考:</div>
        <div><a shape="rect" href="https://www.cnblogs.com/zhoushengxiu/p/5703095.html"
            target="_blank">https://www.cnblogs.com/zhoushengxiu/p/5703095.html</a><br clear="none" /></div>

        <div><span>自定义事件,模拟事件</span></div>
        <div>var event=new Event('test');</div>
        <div>ele.addEventListener('test',function(){})</div>
        <div>ele.dispatch(event )//触发事件</div>
        <div><span>缺点,无法加数据</span></div>
        <div>var event=new CustomEvent('test',obj);</div>
        <div>可以添加自定义参数</div>
      </td>
    </tr>
    <tr>
      <td>
        <div>HTTP协议类</div>
      </td>
      <td>
        <div>1.HTTP协议的主要特点</div>
        <div>2.HTTP报文的组成部分</div>
        <div>3.HTTP方法</div>
        <div>4.POST和GET的区别</div>
        <div>5.HTTP状态码</div>
        <div>6.什么是持久连 接</div>
        <div>7.什么是管线化</div>
      </td>
      <td>
        <div>1.简单快速,灵活,无连接,无状态</div>
        <div>2.请求报文:请求行,请求头,空行,请求体</div>
        <div>响应报文:状态行,响应头,空行,响应体</div>
        <div>请求行:http方法,页面地址,http协议,版本</div>
        <div>请求头,key-value值,让服务端获取客户端信息,比如用户代理</div>
        <div>空行:告诉服务器下面的事请求体了</div>
        <div>请求体:get-post的内容</div>
        <div>响应报文:</div>
        <div>①报文协议及版本;</div>
        <div>②状态码及状态描述;</div>
        <div>③响应报文头，也是由多个属性组成;</div>
        <div>④响应报文体，即我们真正要的“干货”.</div>
        <div>3.GET 获取</div>
        <div>POST 传输</div>
        <div>PUT  更新资源</div>
        <div>DELETE 删除资源</div>
        <div>HEAD 获得报文首部</div>
        <div>4.GET,POST区别:</div>
        <div><img src="./img/f95388308409e54b69504e7ede38ca8a.png" /></div>
        <div>5.状态码:</div>
        <div>1xx：指示信息--表示请求已接收，继续处理.</div>
        <div>2xx：成功--表示请求已被成功接收、理解、接受.</div>
        <div>3xx：重定向--要完成请求必须进行更进一步的操作.</div>
        <div>4xx：客户端错误--请求有语法错误或请求无法实现.</div>
        <div>5xx：服务器端错误--服务器未能实现合法的请求.</div>
        <div>6.持久连接:keep-alive,1.1开始支持</div>
        <div>7.管线化</div>
        <div>&gt;管线化技术——客户端可以发送多次请求到服务端，而不需要等待上一次请求得到响应的时候才能进行下一次请求.实现并行发送请求</div>
        <div>&gt;前提是持久连接的情况下,打包请求和响应</div>
        <div>&gt;仅HTTP/1.1支持此技术（HTTP/1.0不支持），并且只有GET和HEAD要求可以进行管线化，而POST则有所限制.</div>

      </td>
      <td>
        <div>状态码:
          <a shape="rect" href="https://blog.csdn.net/xiaoninvhuang/article/details/70257189"
            target="_blank">https://blog.csdn.net/xiaoninvhuang/article/details/70257189</a><br clear="none" />
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <div>原型链</div>
      </td>
      <td>
        <div>1.创建原型链有几种方法</div>
        <div>2.原型,构造函数,实例,原型链</div>
        <div>3.instanceof原理</div>
        <div>4.new 运算符</div>
        <div>注:</div>
        <div>什么是构造函数:当任意一个普通函数用<br>于创建一类对象时，它就被称作构造函数
        </div>
      </td>
      <td>
        <div>1.</div>
        <div><img src="./img/fd97fb605982f3a602936e606c77ec4b.png" /></div>
        <div>2.<img src="./img/cc35d87fda8e1c28fd8be9989e5e280a.png" /></div>

        <div>3.<img src="./img/c031081256f8dc45b9a460d18beaecb3.png" /></div>
        <div>实际上就是判断 实例对象.__proto__(可以无限__proto__) 与构造函数.prototype是不是引用的同一个地址</div>
        <div>4.</div>
        <div>
          new的工作流程：<br>
          1、创建一个空对象（var obj = {};）<br>
          2、使该空对象继承于构造函数的原型(obj.__proto__ = Foo.prototype;)<br>
          3、使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。(Foo.call(obj, x, y, z);)<br>
          4、由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）
        </div>
      </td>
      <td>
        <div>1.对象就是一个实例</div>
        <div>2.任何函数都可以当做构造函数,new完了一定是构造函数</div>
        <div>3.构造函数都有prototype属性</div>
        <div>4.只要在原型链上的,instanceof返回的结果都是true,比如 o3 instanceof M是true,那么 o3 instanceof Object也是true</div>
        <div class="todo">5.TODO: new的原理</div>
        <div>6.prototype是函数的内置属性，__proto__是对象的内置属性是JS内部使用寻找原型链的属性。
        </div>
        <div>7.object.create()原理:</div>
        <div><a shape="rect" style="color: #0000ee; text-decoration: underline;"
            href="http://www.cnblogs.com/ones/p/8453984.html"
            target="_blank">http://www.cnblogs.com/ones/p/8453984.html</a><br clear="none" /></div>
        <div><span style="color: #e30000;">__proto__和prototype的区别</span></div>
        <div>object.create()可传入参数,指定原型,object.create()本身创建的是一个空对象</div>
        <div>js中的对象都是new +构造函数创建的。而这个构造函数就是我们定义的函数。</div>
        <div>而所有的对象中都有__proto__属性，这个属性就是一个指针，指向构造函数中的prototype属性。</div>
        <div>我们可以做一个简单的验证</div>
        <pre><code class="javascript">var obj1={};
console.log(obj1.__proto__===Object.prototype);
//输出true</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <div>面向对象</div>
      </td>
      <td> </td>
      <td>
        <div>1.类的声明</div>
        <pre><code class="javascript">function Animal (){
  this.name="name";
}
es6:
class Animal2{
  constructor(){
    this.name="name";
  }
}</code></pre>
        <div>2.生成实例 new Animal(),new Animal2</div>
        <div>3.继承&gt;</div>
        <div>call方法(通过构造函数实现继承)</div>
        <div><img src="./img/63b3d32af218c44205a4855b132d0c13.png" /></div>
        <div>缺点:无法继承来自Parent1的原型上的东西,只能部分继承</div>
        <div>&gt;原型链继承</div>
        <div><img src="./img/bb8c286e332984d18c32f077825d220e.png" /></div>
        <div>缺点:</div>
        <div>改变了s1的属性同时也会影响到s2,因为原型链中的原型对象是公用的</div>
        <div><span style="color: #ff0000;">注:</span>实际上new出来的新类.name是不存在的,通过查找新类.__proto__.name才会有,所以是在原型链上查找出来的
        </div>
        <div>&gt;组合方式(企业通用方法)
          <img style="display: block" src="./img/548359686e4cae8d93dacddfb1bb5add.png" /></div>
        <div>缺点:new 2次,构造函数被执行了2次</div>
        <div>第一次:Parent3.call()的时候</div>
        <div>第二次:Child3的原型new Parent3的时候</div>
        <div><span
            style="color: #ff0000;">注:</span>其实s3和s4分别有两套name和play,一份是call出来的,使用时直接s3.name,可以得出,一份是原型链上的s3.__proto__.name可以得出,该方法只是在call的基础上把parent的原型链继承给了Child3而已
        </div>
        <div>优化</div>
        <div><img src="./img/a2e9fbc828164c0a1bfb05ab9e3852d7.png" /></div>
        <div>缺点:constroctor指向父类</div>
        <div>优化</div>
        <div>测试过程中也可以</div>
        <pre><code class="javascript">function Parent4 () {
  this.name = 'parent4';
  this.play = [1, 2, 3];
}
function Child4 () {
  Parent4.call(this);
  this.type = 'child4';
}
Child4.prototype = Parent4.prototype;
Child4.prototype.constructor=Child4;
var s5 = new Child4();
var s6 = new Child4();
console.log(s5, s6);
console.log(s5 instanceof Child4, s5 instanceof Parent4);
console.log(s5.constructor);</code></pre>
        <div>将<span style="color: #e30000;">constructor</span>设置回来即可,但是父类和子类的</div>
        <div>constructor都变成子类了</div>
        <div>&gt;终极优化</div>
        <div><img src="./img/efb8ba3733164fe4fef5afcd8f0cbb5b.png" /></div>
        <div>var o=Object.create(parent)是把参数parent当做原型对象传给o的,所以o并不具备parent的属性,但是o的__proto__具有,因为o.__proto__===parent
        </div>
      </td>
      <td>typeof 能判断哪些类型:<br/>
        1.undefined,string,number,bool,symbol,<br/>2.object(typeof null === 'object'),<br/>3.function
        <img src="./img/20200824163807.png" alt="">
        <div>未掌握://1.constructor</div>
        <div>//2.原型链</div>
        <div><span
            style="color: #ff0000;">注:</span>原型链继承由于new的时候是把原型对象上的属性复制给新对象,于是新对象相当于有两个相同属性,如果新对象为o,那么他既有o.name,又有o.__proto__.name,修改两个的时候互不影响,但是会影响原型链就是原型对象的.prototype,继而影响所有new出来的新对象
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <div>通信类</div>
        <div>复习文件:</div>
      </td>
      <td>
        <div>1.什么是同源策略及限制</div>
        <div>2.前后端如何通信</div>
        <div>3.如何创建ajax</div>
        <div>4.跨域通信的几种方式</div>
      </td>
      <td>
        <div>1.协议,域名和端口不一致的情况下无法操作</div>
        <div>2.AJAX(同源)</div>
        <div>WebSocket(不限制)</div>
        <div>CORS(新的,不限制) 浏览器发现跨域时自动在请求头添加<br>Access-Control-Allow-Origin</div>
        <div>3.</div>
        <div><img src="./img/6e25d499e78d6dc6be390bc6df90a351.png" /></div>
        <div>1). </div>
        <pre><code class="javascript">
var xhr = XMLHttpRequest? 
              new XMLHttpRequest(): 
              new ActiveXObject('Microsoft.XMLHTTP');
          </code></pre>
        <div>2).</div>
        <pre><code class="javascript">
xhr.open(type, url, true);
xhr.send();
xhr.onload(function(){
    data=xhr.responseText
})
          </code></pre>
        <div>4.</div>
        <div><img src="./img/6d3fec632b1d23a3a1e31237a5552ddf.png" /></div>
      </td>
      <td>
        <div>1.jsonp原理:利用script标签可以跨域</div>
        <div>jsonp 利用script的异步加载</div>
        <div>//todo:手写ajax代码,手写一遍jsonp.js</div>
        <div>postMessage传递过来数据时监控方式:</div>
        <div>window.addEventListener('message', onmessage, false);</div>
        <div>Hash传递过来数据时监控方式:</div>
        <div>window.addEventListener('hashchange', onmessage, false);</div>
        <div>4.
        </div>
        <div>jsonp 只能get</div>
        <div>hash的改变不刷新页面,常用于iframe,onhashchange能监控hash的变化</div>
        <div>postMessage:</div>
        <div>WebSocket:</div>
        <div>CORS:</div>
      </td>
    </tr>
    <tr>
      <td>
        <div>安全类</div>
      </td>
      <td>
        <div>1.CSRF</div>
        <div>2.XSS</div>
      </td>
      <td>
        <div>1.跨站请求伪造</div>
        <div><img src="./img/c048aa80868a1743facb80d23b5024c1.png" /></div>
        <div>攻击原理：</div>
        <div>防御措施:.a加token验证</div>
        <div>b.referer验证  来源 </div>
        <div>c.隐藏令牌 一个隐藏的token</div>
        <div>2.跨域脚本攻击</div>
        <div>防范措施:去除评论中的可执行脚本</div>
        <div>两种攻击的区别 a.xss是向网页中插入脚本执行</div>
        <div>b.csrf是利用漏洞执行接口,而且csrf依赖于用户登录网站</div>
      </td>
      <td>
        <div>todo://清楚csrf原理</div>
        <div>1.用户登录A网站,并生成一个cookie</div>
        <div>2.用户访问B,B有一个链接指向A,</div>
        <div>3.用户点击钓鱼链接,于是带着cookie就去了A,达到了模拟用户操作的目的</div>
        <div>防范:加token,因为token是惟一的黑客只能带着cookie去访问,而得不到中的数据,所以也得不到token</div>
        <div><a shape="rect" href="https://blog.csdn.net/a4171175/article/details/78181477"
            target="_blank">https://blog.csdn.net/a4171175/article/details/78181477</a><br clear="none" /></div>
      </td>
    </tr>
    <tr>
      <td>
        <div>算法类</div>
      </td>
      <td>
        <div>1.排序</div>
        <div>2.堆栈,队列,链表</div>
        <div>3.递归</div>
        <div>4.波兰式和逆波兰式</div>
      </td>
      <td>
        <div>1.</div>
        <div>快速排序：</div>
        <div><a shape="rect" href="https://segmentfault.com/a/1190000009426421"
            target="_blank">https://segmentfault.com/a/1190000009426421</a><br clear="none" /></div>
        <div>选择排序：</div>
        <div><a shape="rect" href="https://segmentfault.com/a/1190000009366805"
            target="_blank">https://segmentfault.com/a/1190000009366805</a><br clear="none" /></div>
        <div>希尔排序:</div>
        <div><a shape="rect" href="https://segmentfault.com/a/1190000009461832"
            target="_blank">https://segmentfault.com/a/1190000009461832</a><br clear="none" /></div>
        <div><a shape="rect" href="http://www.cnblogs.com/chengxiao/p/6104371.html"
            target="_blank">http://www.cnblogs.com/chengxiao/p/6104371.html</a><br clear="none" /></div>
        <div>冒泡排序: <span>原理是临近的数字两两进行比较,<br>按照从小到大或者从大到小的顺序进行交换</span>
        </div>
        <div><a shape="rect" href="http://www.cnblogs.com/kaima/archive/2009/09/02/1558615.html"
            target="_blank">点我查看</a>
        </div>
        <div>选择排序是跟某一个数值去换,插入排序是找到位置插入</div>
        <div>2.</div>
        <div><img src="./img/ea09ae160c85f0906590df7ea112a9b8.png" /></div>
        <div>3.</div>
        <div><img src="./img/02c86ac22d32988ff4187f653d260bc3.png" /></div>
        <div>4.</div>
        <img src="./img/36b651826f97325cd57ccecce38c229a.png" /></div>
      </td>
      <td>
        <div>没答上来的技巧:1.先理解题目的意思,实在看不懂,问面试官可否给点提示</div>
        <div>2.判断使用哪种算法,分解难度,想到哪写到哪</div>
        <div>3.写出伪代码</div>
        <div>4.卡住的地方问面试官</div>
        <div>5.说出用哪种算法,说出原理</div>
      </td>
    </tr>
    <tr>
      <td>算法类</td>
      <td>手写深拷贝<img src="./img/20200824163915.png" alt=""></td>
      <td>防抖
        <pre><code class="javascript">function debounce(fn, delay = 500) {
          // timer 是闭包中的
          let timer = null
      
          return function () {
              if (timer) {
                  clearTimeout(timer)
              }
              timer = setTimeout(() => {
                  fn.apply(this, arguments)
                  timer = null
              }, delay)
          }
      }</code></pre>
      </td>
      <td>
        <pre>节流
          <code class="javascript">function throttle(fn, delay = 100) {
          let timer = null
      
          return function () {
              if (timer) {
                  return
              }
              timer = setTimeout(() => {
                  fn.apply(this, arguments)
                  timer = null
              }, delay)
          }
      }</code></pre>
      </td>
    </tr>
    <tr>
      <td>其他问题</td>
      <td>pop,push,unshift,shift作用都是什么,concat,push区别,<br>
        1.pop,删除数组最后一个元素,返回值是删除的那个元素,<br>
        2.push数组末尾添加一个元素,返回值是数组长度<br>
        3.unshift在数组最前面插入数据,返回长度<br>
        4.shift,删除数组第一个元素,返回值是删除的那个元素,<br>
        5.forEach,some,every,reduce都不是纯函数
        注意,他们都不是纯函数(纯函数不会改变原数据,也就是说没有副作用),<br>
        concat,map,filter,slice都是纯函数<br>
        6.push是concat的简化版,concat等于push时打平数组
      </td>
      <td>slice(切片),splice(剪接),区别,<br>
        1.slice是纯函数,作用:截取数组,返回截取的那部分内容<br>
        3.splice不是纯函数,作用:把指定位置的内容替换成传入的内容<br>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>es6的一些常用语法</div>
      </td>
      <td>
        <div>1.变量声明const和let</div>
        <div>2.模板字符串</div>
        <div>3.函数默认参数</div>
        <div>4.箭头函数</div>
        <div>5.拓展的对象功能(简写键值对)</div>
        <div>6.Spread Operator 展开运算符(三个点儿...)</div>
        <div>7.import 和 export</div>
        <div>8. Promise</div>
        <div>9.Generators</div>
      </td>
      <td>
        <div>1.let可以解决闭包问题</div>
        <div>4.</div>
        <pre><code class="javascript">//例如：
[1,2,3].map( x => x + 1 )
//等同于：
[1,2,3].map((function(x){
return x + 1
}).bind(this))
</code></pre>
        <div>5.</div>
        <pre><code class="javascript">function people(name, age) {
  return {
    name,
    age
  };
}</code></pre>
        <div>6.</div>
        <pre><code class="javascript">//数组 
const color = ['red', 'yellow'] 
const colorful = [...color, 'green', 'pink']
console.log(colorful) 
//[red, yellow, green, pink]</code></pre>
        <div>8.</div>
        <pre><code class="javascript">fetch('/api/todos')
.then(res => res.json())
.then(data => ({ data }))
.catch(err => ({ err }));</code></pre>
        <div>9.</div>
        <pre><code class="javascript">// 生成器 
function *createIterator() { yield 1; yield 2; yield 3; }
//生成器能像正规函数那样被调用，但会返回一个迭代器 
let iterator = createIterator(); 
console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2 
console.log(iterator.next().value); // 3</code></pre>
      </td>
      <td>
        <div>参考:</div>
        <div>1.整篇文章:</div>
        <div><a shape="rect" href="https://www.jianshu.com/p/287e0bb867ae"
            target="_blank">https://www.jianshu.com/p/287e0bb867ae</a><br clear="none" /></div>
        <div>2.Promise 原理:</div>
        <div><a shape="rect" href="https://www.cnblogs.com/zhansu/p/6530844.html"
            target="_blank">https://www.cnblogs.com/zhansu/p/6530844.html</a><br clear="none" /></div>
      </td>
    </tr>
    <tr>
      <td>
        <div>箭头函数中的this和普通函数中的this对比</div>
      </td>
      <td>
        <div><a shape="rect" href="https://www.cnblogs.com/fanzhanxiang/p/8888963.html" target="_blank">点我查看</a><br />
        </div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>LocalStorage和sessionStorage的用法以及使用区别</div>
      </td>
      <td>
        <div>localStorage的生命周期是永久性的。即使关闭浏览器，数据也不会销毁，存储大小一般为5M,需要主动去销毁</div>
      </td>
      <td>
        <div>sessionStorage 的生命周期是在浏览器关闭前。<br>
          在整个浏览器未关闭前，其数据一直都是存在的。</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>JS中BOM和DOM的区别与联系</div>
      </td>
      <td>
        <div>javacsript是通过访问BOM对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，可以说，<span
            style="color: #e30000;">BOM包含了DOM(对象)</span>，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档
        </div>
      </td>
      <td>
        <div><a shape="rect" href="https://blog.csdn.net/xiao_tommy/article/details/53231165"
            target="_blank">查看链接</a><br clear="none" /></div>
      </td>
      <td>常用BOM<img src="./img/20200827111806.png" alt=""></td>
    </tr>
    <tr>
      <td>
        <div>变量声明加 var 和不加 var 的区别</div>
      </td>
      <td>
        <div>由于变量声明自带不可删除属性，比较var num = 1 跟 num = 1，前者是变量声明，带不可删除属性，因此无法被删除；后者为全局变量的一个属性，因此可以从全局变量中删除。</div>
      </td>
      <td>
        <div><a shape="rect" href="https://www.cnblogs.com/liuna/p/6140901.html"
            target="_blank">https://www.cnblogs.com/liuna/p/6140901.html</a><br clear="none" /></div>
      </td>
      <td>

      </td>
    </tr>
    <tr>
      <td>
        <div>变量的提升</div>
      </td>
      <td>
        <div>变量提升只提升函数名 而函数提升会提升整个函数题 注意：函数提升在变量提升上面。</div>
      </td>
      <td>
        <div><a shape="rect" href="https://blog.csdn.net/demo_18/article/details/78493489"
            target="_blank">https://blog.csdn.net/demo_18/article/details/78493489</a><br clear="none" /></div>
      </td>
      <td><img src="./img/20190815091557.jpg" /></td>
    </tr>
    <tr>
      <td>
        <div><span>1.一个页面从输入
            URL 到页面加载显示完成，这个过程中都发生了什么？</span></div>
      </td>
      <td>
        <div><span>（1）查找浏览器缓存</span>
        </div>
        <div><span>（2）DNS解析、查找该域名对应的IP地址,找到之后进行三次握手、重定向（301）、发出第二个GET请求</span>
        </div>
        <div><span>（3）进行HTTP协议会话</span>
        </div>
        <div><span>（4）客户端发送报头(请求报头)</span>
        </div>
        <div><span>（5）服务器回馈报头(响应报头),结束开始四次挥手</span>
        </div>
        <div><span>（6）html文档开始下载</span>
        </div>
        <div><span>（7）文档树建立，根据标记请求所需指定MIME类型的文件</span>
        </div>
        <div><span>（8）文件显示</span>
        </div>
      </td>
      <td><img src="./img/QQ20171023-113827@2x.png" /></td>
      <td>应用层(http协议,传输app数据),传输层(tcp,udp),IP层(添加源ip和目标ip),数据链路层(增加mac地址)</td>
    </tr>
    <tr>
      <td>
        <div>jquery扩展</div>
      </td>
      <td>
        <div>1.$.extend</div>
        <div>2.$.fn.extend</div>
      </td>
      <td>
        <pre><code class="javascript">//1.静态扩展
$.extend({
  sayHello: function(txt) {
    console.log('Hello,'+txt);
  }
})
$.sayHello('world'); //调用
//2.实例扩展：
$.fn.extend({
  myPlugin : function(txt) {
    this.css('color','red')
  }
})
$("a").myPlugin(); //调用
//并且实例扩展还能添加参数
options={color:'red',width:'100px'}
$("a").myPlugin(options);
//插件内部再使用$.extend合并对象$.extend(opt,options)</code></pre>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>Vuex</div>
      </td>
      <td>
        <div>Vuex是一个状态管理器，用于管理某些值的变化，统一对值的操作，把组件共享的值抽取出来，以全局模式管理，方法使得控制值的方法可复用</div>
      </td>
      <td>
        <div>1.Vuex中getters相当于一个过滤器，可以在其中添加方法，然后给组件的computed</div>
        <div>2.mutations表示可以调用的方法</div>
        <div>3.vuex的目的类似于将数据提取成model的形式，然后对model进行数据操作并封装成方法给vue的组件中调用：method对应mutations，computed对应state,getters</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>Promise原理</div>
      </td>
      <td>
        <div class="todo" TODO:>TODO:印象笔记可能把数据弄丢了,需要自己找找资料</div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>Angular和Vue的差别</div>
      </td>
      <td>
        <div>1.angular中的双向数据绑定是基于脏检查机制</div>
        <div>vue的双向数据绑定是基于ES5的getter和setter来实现, </div>
        <div>2.vue比angular更轻量, 性能上更高效, 比angular更容易上手, 学习成本低,</div>
        <div>3.而vue可以有过个vue实例,ngview只能有一个, 不能嵌套多个视图</div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>面向对象多态：</div>
      </td>
      <td>
        <div>父类new子类，子类中的方法重写了父类，导致new不同的子类可以表现出不同的状态</div>
      </td>
      <td>
        <div><a shape="rect" href="https://www.cnblogs.com/chenssy/p/3372798.html"
            target="_blank">https://www.cnblogs.com/chenssy/p/3372798.html</a><br clear="none" /></div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div><span style="font-size: 19px; color: #e30000;">二面/三面</span></div>
      </td>
      <td> </td>
      <td>
        <div>赞美面试官研究的深,懂得多</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>渲染机制</div>
      </td>
      <td>
        <div>1.什么是DOCTYPE及作用</div>
        <div>2.浏览器渲染过程</div>
        <div>3.重排Reflow</div>
        <div>4.重绘Repaint</div>
        <div>5.布局Layout</div>
      </td>
      <td>
        <div>1:DTD文档类型定义,DOCTYPE作用是告诉浏览器是哪个DTD</div>
        <div>都有哪些类型:</div>
        <div>4.0有两种模式:严格模式,传统模式</div>
        <div>区别:严格模式不包括展示性和弃用的元素比如&lt;font&gt;已经被废弃</div>
        <div><img src="./img/6ce1278b8ac02e9a5fe2c71d1bae7e8d.png" /></div>
        <div>2.渲染过程:</div>
        <div><img src="./img/181bc7ce0b40393c1a5f06baf7b549ec.png" /></div>
        <div>3.&gt;</div>
        <ul>
          <li>
            <div>重排:定义:每个元素都有自己的盒子,浏览器根据CSS和js结算处结果让元素出现在他的位置,重新修改dom之后浏览器该做的事</div>
          </li>
        </ul>
        <div>触发条件:增加删除,修改dom节点会导致重排或重绘</div>
        <div>&gt;移动dom位置</div>
        <div>&gt;修改部分CSS,如宽高</div>
        <div>&gt;Resize或者Scroll窗口有可能</div>
        <div>&gt;修改网页字体</div>
        <ul>
          <li>
            <div>重绘:页面要出现的内容统统画在屏幕上</div>
          </li>
        </ul>
        <div>触发条件:DOM改动</div>
        <div>CSS改动</div>
        <div>repaint无法避免,减少方法:使用文档片段,一次添加</div>
        <div>区别:元素或内容的重新绘制:比如元素颜色改变,形状改变,需要重绘,</div>
        <div>位置改变则需要重[]排</div>
      </td>
      <td>
        <div>视频4-1</div>
      </td>
    </tr>
    <tr>
      <td><span style="color:red">问题:浏览器渲染过程</span></td>
      <td>为什么要把css放在head里:<br />因为放在最后页面先渲染html,没有样式,然后渲染到了css,如果网速不好或者电脑慢,会出现样式突然变化的现象,因为页面重绘了,导致了浪费计算机性能</td>
      <td>
        为什么要把js放在最后:<br />因为js的加载会暂停页面的渲染,因为js里可能有会修改html内容的代码,放在html中间会导致页面渲染时间变长,极端情况下会导致用户看不到完整内容,放在head里都获取不到html元素
      </td>
      <td><img src="./img/20200828143333.png" alt=""></td>
    </tr>
    <tr>
      <td>
        <div>js运行机制</div>
      </td>
      <td>
        <div><img src="./img/612928863156f8fac7f7adbaa3926f8f.png" /></div>
      </td>
      <td>
        <div>1.settimeout运行机制<br>
          <img src="./img/77a654ffeb39f2978c2efbc4551dd82d.png" /></div>
        <div>2.</div>
        <div><img src="./img/d44884b5be3b425e627cbe061d9939a3.png" /></div>
        <div>3.</div>
        <div><img src="./img/c9ed179666e10f14ae8ff5a4f31b56ef.png" /></div>
        <div>4.</div>
        <div><img src="./img/6f02e08b46b1b7d1f1099243306b0d65.png" /></div>

        <div><img src="./img/f26d6b526cbfd5092a37362d8a647a1e.png" /></div>
      </td>
      <td>
        <div>1.答案为 132,因为settimeout浏览器有最小时间,虽然写的是0,实际上也不会是0,浏览器优先响应同步任务</div>
        <div>2.答案为A,while为死循环,而且是循环任务,所以永远不会输出B</div>
        <div>3.答案还是A,由于js是同步的,虽然settimeout到时间了,但是while还没有执行完,B依然要等待</div>
        <div>4.输出结果永远是4</div>
        <div>   解决方法:使用闭包</div>
        <div>上面这个是错误的,会立即输出0-5</div>
        <pre><code class="javascript">for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}</code></pre>
        <div>event loop</div>
        <div>任务队列,</div>
        <div>执行栈空了之后继续监听任务队列,如果有,就取出来执行,反复的循环就是event loop</div>
      </td>
    </tr>
    <tr>
      <td>bind()方法</td>
      <td>
        <div><a shape="rect" href="http://www.cnblogs.com/xxxxBW/p/4914567.html" target="_blank">链接</a><br
            clear="none" /></div>
      </td>
      <td>
        <div>类似于call,apply,但是只绑定不执行</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>call,apply</td>
      <td>
        apply 是把参数放在数组里。　　
        call 需要把参数按顺序传递进去
      </td>
      <td>
        <pre><code class="javascript">func.call(this,arg1,arg2);
func.apply(this,[arg1,arg2])</code></pre>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>闭包相关问题</div>
      </td>
      <td>
        <div><a href="http://www.cnblogs.com/qieguo/p/5457040.html" target="_blank">(面试)</a></div>
        <div><a href="https://www.jianshu.com/p/3a3fbed1ddf1" target="_blank">(原理)</a></div>
        <div>a.闭包的作用:模拟私有变量</div>
      </td>
      <td>
        <div>
          当一个function中包含(或return)另一个function,并且内部的function引用外部的变量,造成外部变量无法销毁,这样一大块代码就叫做闭包。闭包中所有的变量的查找，是在函数定义的地方，向上级作用域查找,不是在执行的地方！！！<br>这是js中的一种特殊现象,以前只有var,所以使用闭包来控制作用域,现在有let,const了,就不太需要了,目前可以作为私有变量去用,类似于get,set,不过又有definePropty<br />
        </div>
        <div><a href="http://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank">全面理解Javascript闭包和闭包的几种写法及用途</a>
        </div>
        <div>a.<a href="https://blog.csdn.net/u011240877/article/details/70202456" target="_blank">JavaScript
            的闭包用于什么场景</a></div>
      </td>
      <td>
        <pre><code class="javascript">// 函数作为返回值
        function create() {
            const a = 100
            return function () {
                console.log(a)
            }
        }
        
        const fn = create()
        const a = 200
        fn() // 100
        
        // 函数作为参数被传递
        function print(fn) {
            const a = 200
            fn()
        }
        const a = 100
        function fn() {
            console.log(a)
        }
        print(fn) // 100</code></pre>
      </td>
    </tr>
    <tr>
      <td>
        <div>this指向性问题</div>
      </td>
      <td>
        <div>普通函数内部的this分两种情况，严格模式和非严格模式。</div>
      </td>
      <td>
        <div>非严格模式下，this 默认指向全局对象window</div>
        <div>而严格模式下， this为undefined</div>
        <div>箭头函数可以捕获其所在上下文的this值</div>
      </td>
      <td>
        <div><a shape="rect" href="http://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank">this
            指向详细解析（箭头函数）</a></div>
      </td>
    </tr>
    <tr>
      <td>博客园</td>
      <td>
        <div><a href="https://www.cnblogs.com/ones" target="_blank">https://www.cnblogs.com/ones</a></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div>vue 双向绑定实现</div>
      </td>
      <td>
        <div>Object.defineProperty()</div>
      </td>
      <td>
        <div><img src="./img/2091638fc3435786a698bdafb933faa7.png" /></div>
      </td>
      <td>
        <div>原理:利用defineProperty的set方法进行劫持</div>
        <div>缺点:只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。(百度说的)</div>
        <div>新方法proxy.至少性能会更好</div>
      </td>
    </tr>
    <tr>
      <td>
        <div>页面性能类(性能优化)</div>
      </td>
      <td>
        <div><img src="./img/1a6903133f0f4684ac91d4478ec1d4c5.png" /></div>

      </td>
      <td>
        <div>2.</div>
        <div><img src="./img/c10cafcac57d95fc5562d76c015695c3.png" /></div>
        <div>2.1.1)动态创建节点,用js创建</div>
        <div>2),3)js标签写入即可</div>
        <div>defer只有在网页完成后才可以执行</div>
        <div>3.</div>
        <div><img src="./img/2b647fd4fde749d8b0e8d81a7bca21eb.png" /></div>
        <div>3.1.1)如果报文头两条都有以第二条为准</div>
        <div>1.2)last-那个是响应报文返回的时间,if-是请求报文中附带的,第一次获得时二者时间是一致的</div>
        <div>Etag是一个hash值,判断文件是否有内容变化,响应报文中带,if-none是请求中给出,二者值一致 </div>
        <div>5.第一个标签.https网站一般浏览器默认关闭a标签的预解析,使用该标签强制打开a标签预解析</div>
        <div>第二个</div>
      </td>
      <td><img src="./img/20200828144014.png" alt=""><img src="img/20200828144449.png" alt="">
        对比webpack:<br>1.代码压缩,<br>2文件合并,引入了多个文件和库,生成只有几个文件<br>3.缓存,不改文件内容,hash值不变</td>
    </tr>
    <tr>
      <td>
        <div>错误监控类</div>
      </td>
      <td>
        <div><img src="./img/d23618e562111a74f9cba0db9baa1b24.png" /></div>
      </td>
      <td>
        <div>问法:如何保证产品质量</div>
        <div><img src="./img/a8d8b7a029c94f1e0759f4ade2fbc7e8.png" /></div>
        <div><img src="./img/c811e11dcf27f5308fba4146b80d4b12.png" /></div>
        <div>1.object.onerror:object表示元素:例如image或者script标签,都有onerror事件</div>
        <div>2.object.onerror专用于资源加载错误</div>
        <div>window.onerror专用于即时运行错误</div>
        <div>因为object.onerror不冒泡</div>
        <div>3.performance.getEntries()高级浏览器可用,能显示出成功加载的资源,用所有资源减去成功的,可得到失败的</div>
        <div>4.Error事件不冒泡,但是可以捕获</div>
        <div><img src="./img/6bed08692e4ba1bd8ba84053e61310c6.png" /></div>
        <div>1.在客户端加入代码</div>
        <div>2.在服务端加入代码</div>
        <div><img src="./img/6fee17a0dfcd1f9cfee661bcf61a68fe.png" /></div>
        <div>1.可以做到,但是不通用</div>
        <div>2.代码:</div>
        <div><img src="./img/cf212c33c87af3cfd444bcd0e2023475.png" /></div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div><span class="title">三面/四面</span></div>
      </td>
      <td>
        <div><img src="./img/e217e6d2e7cda333eda86afc3a0d4146.png" /></div>
      </td>
      <td>
        <div>1.项目架构,技术能力,人员组织,技术难点攻克,轻描淡写没亮点不行</div>
        <div>2.提前演练第一条内容,把握时间</div>
        <div>3.如果是业务负责人,即使没问到项目,也要把准备的说出来,如何找时机,当面试官表现出没兴趣时,要抓住时机或者聊得很投机的时候</div>
        <div>4.用词说话要谦虚,但是要表现自己,不能谦虚</div>
        <div>5.不要把话说满,留一部分让面试官去问</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/3d00c743801cae0a98131f1d9a6bbc8d.png" /></div>
      </td>
      <td>
        <div><img src="./img/89ff985cadd69a11e241f9b636e138f1.png" /></div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/be6826b1f8bd0233095d75b61f34bc09.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/38eb4a94c73aaa4c38de130ea5a94d97.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/69186488538a1c9c6fed69b37afb06ac.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/2f4533d16cfb1c597e878166ef55954e.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div><span style="font-size: 19px; color: #e30000;">终面</span></div>
      </td>
      <td>
        <div><img src="./img/648431cf7d2053c86cab5aef6c2d4836.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/08f102624f6f4187610b29016fbaf645.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/1d95fd0475317713b2c6506dcbb08f40.png" /></div>
      </td>
      <td>
        <div>1.努力超越别人,做到了比别人强</div>
        <div>2.可以简单讲讲业务,遇到了什么问题,为了找到最好的解决方法如何努力,比如加班什么的</div>
        <div>3.周末喜欢干什么,比如听听别人的分享,学习点什么</div>
        <div>4.表现出非常愿意配合公司加班,表现的有责任心</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/1fd09ab3ec129d4d00c10470eb1a9bb5.png" /></div>
        <div>5.多赞美公司和hr</div>
      </td>
      <td>
        <div>拥有激情和热情</div>
        <div>希望公司提供机会,比如:学习的机会,交流的机会,进修,技术分享会等等</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td><img src="./img/20200831095936.png" alt=""></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <div><span class="title">总结</span></div>
      </td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/002fa6068b9fb88aff43083777956ce4.png" /></div>
      </td>
      <td>
        <div>1.社招一定要看准职位描述,分析需要的技术栈,简历一定要和职位描述一致</div>
        <div>2.自我介绍一定要打草稿,面试官有可能要根据自我描述来问问题</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/c42fbabff7a36dac7d556d032d7ca716.png" /></div>
      </td>
      <td>
        <div>不会的问题要思考一下,不要直接说不会</div>
      </td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/0d60e908b4d9ebec50b05f2ab4675c97.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td>
        <div><img src="./img/00fa26140a7557cadf15d5f6e023a7f3.png" /></div>
      </td>
      <td></td>
      <td></td>
    </tr>
  </table>
</body>

</html>